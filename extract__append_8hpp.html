<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Binary Serialize: /github/workspace/include/serialize/extract_append.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Binary Serialize
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_d6dce8604daa6d974602991ede05feb6.html">serialize</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#concepts">Concepts</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">extract_append.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Functions to extract arithmetic binary values from a byte buffer (in either endian order) to native format; conversely, given an arithmetic binary value, append it to a buffer of bytes in the specified endian order.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="byteswap_8hpp_source.html">serialize/byteswap.hpp</a>&quot;</code><br />
<code>#include &lt;concepts&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;bit&gt;</code><br />
<code>#include &lt;array&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for extract_append.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="extract__append_8hpp__incl.png" border="0" usemap="#a_2github_2workspace_2include_2serialize_2extract__append_8hpp" alt=""/></div>
<map name="a_2github_2workspace_2include_2serialize_2extract__append_8hpp" id="a_2github_2workspace_2include_2serialize_2extract__append_8hpp">
<area shape="rect" title="Functions to extract arithmetic binary values from a byte buffer (in either endian order) to native f..." alt="" coords="242,5,430,46"/>
<area shape="rect" href="byteswap_8hpp.html" title="This is an implementation of the C++ 23 std::byteswap function, for use in pre C++ 23 applications." alt="" coords="122,94,273,120"/>
<area shape="poly" title=" " alt="" coords="303,49,233,88,230,84,300,44"/>
<area shape="rect" title=" " alt="" coords="5,168,80,193"/>
<area shape="poly" title=" " alt="" coords="242,40,168,60,132,76,99,96,73,124,55,155,51,152,69,121,95,92,129,71,166,55,240,35"/>
<area shape="rect" title=" " alt="" coords="111,168,150,193"/>
<area shape="poly" title=" " alt="" coords="242,46,162,67,130,81,111,96,106,109,106,123,117,154,112,155,100,124,100,108,107,92,128,76,160,62,240,41"/>
<area shape="rect" title=" " alt="" coords="178,168,227,193"/>
<area shape="poly" title=" " alt="" coords="331,47,313,83,287,121,264,143,239,161,236,157,260,139,283,118,309,81,326,45"/>
<area shape="rect" title=" " alt="" coords="272,168,336,193"/>
<area shape="poly" title=" " alt="" coords="339,47,338,81,332,120,319,155,314,153,327,119,332,81,334,46"/>
<area shape="rect" title=" " alt="" coords="369,168,444,193"/>
<area shape="poly" title=" " alt="" coords="347,45,397,152,392,154,342,47"/>
<area shape="rect" title=" " alt="" coords="450,94,510,120"/>
<area shape="poly" title=" " alt="" coords="373,44,446,84,443,88,371,49"/>
<area shape="rect" title=" " alt="" coords="534,94,615,120"/>
<area shape="poly" title=" " alt="" coords="396,44,524,86,523,91,395,49"/>
<area shape="poly" title=" " alt="" coords="172,123,84,163,81,158,170,118"/>
<area shape="poly" title=" " alt="" coords="188,122,154,158,150,154,184,118"/>
<area shape="poly" title=" " alt="" coords="201,120,203,152,198,152,195,120"/>
<area shape="poly" title=" " alt="" coords="217,118,274,156,272,161,214,122"/>
<area shape="poly" title=" " alt="" coords="234,118,357,160,356,165,232,123"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="extract__append_8hpp__dep__incl.png" border="0" usemap="#a_2github_2workspace_2include_2serialize_2extract__append_8hppdep" alt=""/></div>
<map name="a_2github_2workspace_2include_2serialize_2extract__append_8hppdep" id="a_2github_2workspace_2include_2serialize_2extract__append_8hppdep">
<area shape="rect" title="Functions to extract arithmetic binary values from a byte buffer (in either endian order) to native f..." alt="" coords="105,5,294,46"/>
<area shape="rect" href="binary__serialize_8hpp_source.html" title=" " alt="" coords="5,94,194,135"/>
<area shape="poly" title=" " alt="" coords="167,58,124,96,120,92,164,54"/>
<area shape="rect" href="extract__append__test_8cpp.html" title="Test scenarios for extract_val and append_val functions." alt="" coords="218,94,384,135"/>
<area shape="poly" title=" " alt="" coords="236,54,280,92,276,96,232,58"/>
</map>
</div>
</div>
<p><a href="extract__append_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptchops_1_1integral__or__byte.html">chops::integral_or_byte</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a459b2f0978a1390fc05186a26c495777" id="r_a459b2f0978a1390fc05186a26c495777"><td class="memTemplParams" colspan="2">template&lt;std::endian BufEndian, integral_or_byte T&gt; </td></tr>
<tr class="memitem:a459b2f0978a1390fc05186a26c495777"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">constexpr</a> <a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="extract__append_8hpp.html#a459b2f0978a1390fc05186a26c495777">chops::extract_val</a> (<a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">const</a> std::byte *<a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">buf</a>) <a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">noexcept</a></td></tr>
<tr class="memdesc:a459b2f0978a1390fc05186a26c495777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a value from a <code>std::byte</code> buffer into a fundamental integral or <code>std::byte</code> type in native endianness, swapping bytes as needed.  <br /></td></tr>
<tr class="separator:a459b2f0978a1390fc05186a26c495777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af439426dbbcbf67b97170fa982159495" id="r_af439426dbbcbf67b97170fa982159495"><td class="memTemplParams" colspan="2">template&lt;std::endian BufEndian, integral_or_byte T&gt; </td></tr>
<tr class="memitem:af439426dbbcbf67b97170fa982159495"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">chops::append_val</a> (std::byte *buf, const T &amp;val) noexcept</td></tr>
<tr class="memdesc:af439426dbbcbf67b97170fa982159495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an integral or <code>std::byte</code> value to a <code>std::byte</code> buffer, swapping into the specified endian order as needed.  <br /></td></tr>
<tr class="separator:af439426dbbcbf67b97170fa982159495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76962a0d08ba32f2a35e5ece05b6170" id="r_ad76962a0d08ba32f2a35e5ece05b6170"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral T&gt; </td></tr>
<tr class="memitem:ad76962a0d08ba32f2a35e5ece05b6170"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">constexpr</a> std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="extract__append_8hpp.html#ad76962a0d08ba32f2a35e5ece05b6170">chops::append_var_int</a> (std::byte *<a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">output</a>, <a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">T</a> <a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">val</a>)</td></tr>
<tr class="memdesc:ad76962a0d08ba32f2a35e5ece05b6170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an unsigned integer into a variable length buffer of bytes using the MSB (most significant bit) algorithm.  <br /></td></tr>
<tr class="separator:ad76962a0d08ba32f2a35e5ece05b6170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad860e80909d613ae526cfb18696c4dc6" id="r_ad860e80909d613ae526cfb18696c4dc6"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral T&gt; </td></tr>
<tr class="memitem:ad860e80909d613ae526cfb18696c4dc6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">constexpr</a> <a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="extract__append_8hpp.html#ad860e80909d613ae526cfb18696c4dc6">chops::extract_var_int</a> (<a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">const</a> std::byte *<a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">input</a>, std::size_t <a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">input_size</a>)</td></tr>
<tr class="memdesc:ad860e80909d613ae526cfb18696c4dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a buffer of <code>std::bytes</code> that hold a variable sized integer, decode them into an unsigned integer.  <br /></td></tr>
<tr class="separator:ad860e80909d613ae526cfb18696c4dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions to extract arithmetic binary values from a byte buffer (in either endian order) to native format; conversely, given an arithmetic binary value, append it to a buffer of bytes in the specified endian order. </p>
<p>The functions in this file are low-level. They handle fundamental arithmetic types and extracting or appending to <code>std::byte</code> buffers. It is meant to be the lower layer of serializing utilities, where the next higher layer provides buffer management, sequences, and overloads for specific types such as <code>std::string</code>, <code>bool</code>, and <code>std::optional</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The variable sized integer functions (<code>extract_var_int</code>, <code>append_var_int</code>) support the variable byte integer type in MQTT (Message Queuing Telemetry Transport), a commonly used IoT protocol. The code in this header is adapted from a Techoverflow.net article by Uli Koehler and published under the CC0 1.0 Universal license: <a href="https://techoverflow.net/2013/01/25/efficiently-encoding-variable-length-integers-in-cc/">https://techoverflow.net/2013/01/25/efficiently-encoding-variable-length-integers-in-cc/</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Cliff Green, Roxanne Agerone, Uli Koehler</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2019-2024 by Cliff Green, Roxanne Agerone</dd></dl>
<p>Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>) </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af439426dbbcbf67b97170fa982159495" name="af439426dbbcbf67b97170fa982159495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af439426dbbcbf67b97170fa982159495">&#9670;&#160;</a></span>append_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::endian BufEndian, integral_or_byte T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t chops::append_val </td>
          <td>(</td>
          <td class="paramtype">std::byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append an integral or <code>std::byte</code> value to a <code>std::byte</code> buffer, swapping into the specified endian order as needed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BufEndian</td><td>The endianness of the buffer.</td></tr>
    <tr><td class="paramname">T</td><td>Type of value to append to buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>The <code>BufEndian</code> enum must be specified, but the type of the passed in value can be deduced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to array of <code>std::bytes</code> big enough to hold the bytes of the value.</td></tr>
    <tr><td class="paramname">val</td><td>Value in native endian order to append to buf.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes copied into the <code>std::byte</code> buffer.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The buffer must already be allocated to hold at least <code>sizeof(T)</code> bytes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See note above about floating point values. </dd></dl>

</div>
</div>
<a id="ad76962a0d08ba32f2a35e5ece05b6170" name="ad76962a0d08ba32f2a35e5ece05b6170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76962a0d08ba32f2a35e5ece05b6170">&#9670;&#160;</a></span>append_var_int()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t chops::append_var_int </td>
          <td>(</td>
          <td class="paramtype">std::byte *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">T</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode an unsigned integer into a variable length buffer of bytes using the MSB (most significant bit) algorithm. </p>
<p>Given an integer, store the value in 1 or 2 or 3 or more bytes depending on the value. If small (under 128) the value is stored in one byte. If the value is greater than 127, the most significant bit in the first byte is set to 1 and the value is stored in two bytes. This logic is repeated as necessary.</p>
<p>This algorithm optimizes space when most of the values are small. If most of the values are large, this algorithm is inefficient, needing more buffer space for the encoded integers than if fixed size integer buffers were used.</p>
<p>The output of this function is (by definition) in little-endian order. However, as long as the two corresponding functions (or equivalent algorithms) are used consistently, the endianness will not matter. There is no byte swapping performed, and encoding and decoding will result in the native endianness of the platform. I.e. this works whether serialization is big-endian or little-endian.</p>
<dl class="section note"><dt>Note</dt><dd>Signed types are not supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The input value. Any standard unsigned integer type is allowed.</td></tr>
    <tr><td class="paramname">output</td><td>A pointer to a preallocated array of <code>std::bytes</code> big enough for the output. A safe minimum size is 5 bytes for 32 bit integers, 10 bytes for 64 bit integers and 3 bytes for 16 bit integers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written to the output array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The output buffer must already be allocated large enough to hold the result. </dd></dl>

</div>
</div>
<a id="a459b2f0978a1390fc05186a26c495777" name="a459b2f0978a1390fc05186a26c495777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459b2f0978a1390fc05186a26c495777">&#9670;&#160;</a></span>extract_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::endian BufEndian, integral_or_byte T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T chops::extract_val </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">const</a> std::byte *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a value from a <code>std::byte</code> buffer into a fundamental integral or <code>std::byte</code> type in native endianness, swapping bytes as needed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BufEndian</td><td>The endianness of the <code>std::byte</code> buffer.</td></tr>
    <tr><td class="paramname">T</td><td>Type of return value.</td></tr>
  </table>
  </dd>
</dl>
<p>Since <code>T</code> cannot be deduced, it must be specified when calling the function. If the endianness of the buffer matches the native endianness, no swapping is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to an array of <code>std::bytes</code> containing an object of type T in network byte order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value in native endian order.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The buffer must contain at least <code>sizeof(T)</code> bytes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Floating point swapping is not supported.</dd></dl>
<p>Earlier versions did support floating point, but it is brittle - the floating point representation must exactly match on both sides of the serialization (most modern processors use IEEE 754 floating point representations). A byte swapped floating point value cannot be directly accessed (e.g. passed by value), due to the bit patterns possibly representing NaN values, which can generate hardware traps, either causing runtime crashes or silently changing bits within the floating point number. An integer value, however, will always have valid bit patterns, even when byte swapped. </p>

</div>
</div>
<a id="ad860e80909d613ae526cfb18696c4dc6" name="ad860e80909d613ae526cfb18696c4dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad860e80909d613ae526cfb18696c4dc6">&#9670;&#160;</a></span>extract_var_int()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T chops::extract_var_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="extract__append_8hpp.html#af439426dbbcbf67b97170fa982159495">const</a> std::byte *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>input_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a buffer of <code>std::bytes</code> that hold a variable sized integer, decode them into an unsigned integer. </p>
<p>For consistency with the <code>append_var_int</code> function, only unsigned integers are supported for the output type of this function.</p>
<dl class="section note"><dt>Note</dt><dd>Signed types are not supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A variable-length encoded integer stored in a buffer of <code>std::bytes</code>.</td></tr>
    <tr><td class="paramname">input_size</td><td>Number of bytes representing the integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value in native unsigned integer format. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
